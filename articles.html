<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="utf-8">
	<title>
	DASP - Articles
</title>
	<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

	<!-- bootstrap.css -->
	<link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0/css/bootstrap.min.css" integrity="sha384-Gn5384xqQ1aoWXA+058RXPxPg6fy4IWvTNh0E263XmFcJlSAwiGgFAW/dAiS6JXm" crossorigin="anonymous">
	<!-- highlight code -->
	<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css">
	<!-- custom -->
	<link rel="stylesheet" href="styles.css">
	<!-- fontawesome.js -->
	<script defer src="https://use.fontawesome.com/releases/v5.0.8/js/all.js"></script>
	<!-- favicon stuff :/ -->
	<link rel="apple-touch-icon" sizes="57x57" href="favicon/apple-icon-57x57.png">
	<link rel="apple-touch-icon" sizes="60x60" href="favicon/apple-icon-60x60.png">
	<link rel="apple-touch-icon" sizes="72x72" href="favicon/apple-icon-72x72.png">
	<link rel="apple-touch-icon" sizes="76x76" href="favicon/apple-icon-76x76.png">
	<link rel="apple-touch-icon" sizes="114x114" href="favicon/apple-icon-114x114.png">
	<link rel="apple-touch-icon" sizes="120x120" href="favicon/apple-icon-120x120.png">
	<link rel="apple-touch-icon" sizes="144x144" href="favicon/apple-icon-144x144.png">
	<link rel="apple-touch-icon" sizes="152x152" href="favicon/apple-icon-152x152.png">
	<link rel="apple-touch-icon" sizes="180x180" href="favicon/apple-icon-180x180.png">
	<link rel="icon" type="image/png" sizes="192x192"  href="favicon/android-icon-192x192.png">
	<link rel="icon" type="image/png" sizes="32x32" href="favicon/favicon-32x32.png">
	<link rel="icon" type="image/png" sizes="96x96" href="favicon/favicon-96x96.png">
	<link rel="icon" type="image/png" sizes="16x16" href="favicon/favicon-16x16.png">
	<link rel="manifest" href="favicon/manifest.json">
	<meta name="msapplication-TileColor" content="#ffffff">
	<meta name="msapplication-TileImage" content="favicon/ms-icon-144x144.png">
	<meta name="theme-color" content="#ffffff">
</head>
<body data-spy="scroll" data-target="#top10">

	<!-- navbar -->
	<nav class="navbar navbar-expand-lg real navbar-light" style="margin-bottom:20px;">
		<a class="navbar-brand" href="/">
			<img src="ncc.png" alt="logo" style="width:100px">
		</a>
		<button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
			<span class="navbar-toggler-icon"></span>
		</button>

		<div class="collapse navbar-collapse" id="navbarSupportedContent">
			<ul class="navbar-nav mr-auto">
				<li class="nav-item ">
					<a class="nav-link" href="index.html">Top 10</a>
				</li>
				<li class="nav-item ">
					<a class="nav-link" href="articles.html">Articles</a>
				</li>
				<li class="nav-item ">
					<a class="nav-link" href="timeline.html">Timeline</a>
				</li>
				<li class="nav-item">
					<a class="nav-link" href="https://consensys.github.io/smart-contract-best-practices/" target="_blank">Best Practices</a>
				</li>
				<li>
					<a class="nav-link" href="https://github.com/nccgroup/GOATCasino" target="_blank">Capture The Flag</a>
				</li>
			</ul>
			<ul class="navbar-nav my-2 my-lg-0">
				<li class="nav-item">
					<a class="nav-link" data-toggle="modal" data-target="#aboutModal" href="#">About</a>
				</li>
				<li class="nav-item">
					<a class="nav-link" href="mailto:uscons-info@nccgroup.trust">Contact</a>
				</li>
				<li class="nav-item">
					<a class="nav-link" href="https://github.com/CryptoServices/dasp" target="_blank">Github</a>
				</li>
			</ul>
		</div>
	</nav>

	<!-- about modal -->
	<div id="aboutModal" class="modal" tabindex="-1" role="dialog" aria-labelledby="aboutModal" aria-hidden="true">
	  <div class="modal-dialog" role="document">
	    <div class="modal-content">
	      <div class="modal-header">
	        <h5 class="modal-title">About</h5>
	        <button type="button" class="close" data-dismiss="modal" aria-label="Close">
	          <span aria-hidden="true">&times;</span>
	        </button>
	      </div>
	      <div class="modal-body">
	        <p>This page was concocted by:</p>
        	<ul>
        		<li><a href="https://www.cryptologie.net" target="_blank">David Wong</a></li>
        		<li><a href="https://twitter.com/mah3mm" target="_blank">Mason Hemmel</a></li>
        	</ul>
	       	<p>We'd like to thank the following people for their precious help:</p>
	       	<ul>
	       		<li><a href="https://twitter.com/matthewdif" target="_blank">Matthew Di Ferrante</a></li>
	       	</ul>
	      </div>
	      <div class="modal-footer">
	        <button type="button" class="btn btn-secondary" data-dismiss="modal">Close</button>
	      </div>
	    </div>
	  </div>
	</div>

	<!-- container -->
	<div class="container">

		
<!-- blogs -->
 	
    <div class="card">
    <div class="card-header">
        <h2 id="smart-contract-insecurity----broken-access-control">Smart Contract (in)Security – Bad Arithmetic</h2>
    </div>
    <ul class="card-subheader list-group list-group-flush">
       <li class="list-group-item">Written by <i class="fas fa-user"></i> Eric Schorn on <i class="fas fa-calendar"></i> 5 November 2018</li>
     </ul>
    <div class="card-content">

<h1 class="article-heading"></h1>

<p>This blog post is the second in a series that will describe some simple real-world <a href="https://www.investopedia.com/terms/s/smart-contracts.asp">smart contract</a> security bugs, how they were exploited, the resulting impacts and the corresponding code fixes. So far, we have reached $30M USD of our series target of more than $250M USD in losses directly attributable to smart contract security bugs. This time, we will make two deposits of exactly 57,896,044,618,658,097,711,785,492,504,343,953,926,634,992,332,820,282,019,728,792,003,956,564,819,968 tokens each, for a grand total of 0 tokens!</p>

<p><strong>What are smart contracts?</strong> To summarize the full background <a href="https://www.nccgroup.trust/us/about-us/newsroom-and-events/blog/2018/september/smart-contract-insecurity-broken-access-control/">found in the first blog post</a>, smart contracts are relatively short, publicly-accessible programs capable of owning large amounts of money and that execute complex transaction logic in an unchangeable and unstoppable fashion on a platform that is rapidly evolving alongside its tools. <a href="http://solidity.readthedocs.io/en/v0.4.24/">Solidity</a> is a new language created specifically for <a href="https://www.ethereum.org/">Ethereum</a>-based smart contracts that compiles to bytecode and is ultimately executed in the Ethereum Virtual Machine. Smart contracts are here today with well over <a href="https://coinmarketcap.com/currencies/ethereum/">$1B USD of Ethereum changing hands daily</a>.</p>

<p><strong>Bugs are bad!</strong> One of the primary challenges limiting the progress of smart contract adoption is security. It is well known that “every program always has one more bug” and <a href="http://sunnyday.mit.edu/accidents/MCO_report.pdf">some bugs can be catastrophic</a>. Smart contracts can provide extremely visible, immediate, and impactful examples of code gone wrong.</p>

<p><strong>The old is new again.</strong> This particular blog post will specifically cover <strong>bad arithmetic</strong> (such as integer overflow). While smart contracts provide a <a href="http://dasp.co/#item-3">new context with unique novelties</a>, this is most certainly not a new problem. Bad arithmetic occupies the attention of almost an entire section in the <a href="https://wiki.sei.cmu.edu/confluence/pages/viewpage.action?pageId=88487628">SEI CERT Oracle Coding Standard for Java</a>. Other languages suffer from the exact same scary scenarios, and these vulnerabilities map to several Common Weakness Enumerations, <a href="https://cwe.mitre.org/data/definitions/190.html">including #190</a>. Smart contracts offer some new and cool challenges related to their public execution environment, unchangeable nature, variety of stakeholder categories and high logical complexity.</p>

<p><strong>Your very own crypto-currency.</strong> The most popular and visible type of contract on Ethereum involves issuing a custom crypto-currency (also called tokens) - <a href="https://medium.com/bitfwd/how-to-issue-your-own-token-on-ethereum-in-less-than-20-minutes-ac1f8f022793">you can do it yourself in less than 20 minutes</a>. This type of contract essentially <a href="https://medium.com/@jgm.orinoco/understanding-erc-20-token-contracts-a809a7310aa5">implements a data structure that keeps track of balances</a>, along with a few functions that perform transfers by correctly adjusting account balances in response to transactions. The most popular <a href="https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20.md">token standard is ERC-20</a> with hundreds and hundreds <a href="https://etherscan.io/tokens">of token varieties</a> implementing the standard wich allows them to be tracked and used by exchanges, tools and other smart contracts. Some of these tokens will likely <a href="https://blog.coinbase.com/adding-erc20-support-to-coinbase-fe9cba6782b">arrive on mainstream trading exchanges</a> in the near future.</p>

<p><strong>Show me the code.</strong> Let’s have a look at the actual code implementing BeautyChainToken, which can be easily <a href="https://etherscan.io/address/0xc5d105e63711398af9bbff092d4b6769c82f793d#code">found on Etherscan</a>. Scrolling through the code reveals the implementation of a library named SafeMath near the very top, followed by a series of contracts that build on top of each other. Ignore all the confusing stuff, but note that there are frequent references to variables called <code>to</code>, <code>from</code>, <code>amount</code> and <code>balances</code> as well as functions called <code>transfer()</code> and <code>approve()</code>. This is the actual recipe for a fully functional token in less than 300 lines of code.</p>

<p>Let’s inspect the <strong><code>batchTransfer()</code></strong> function starting on line 255 which is replicated below. It takes two parameters – the first parameter (<code>_receivers</code>) is a list of destination account addresses, and the second parameter (<code>_value</code>) is the number of tokens to transfer to each destination account address. Line 256 calculates the number of receiver addresses in the list and then line 257 can calculate the total <code>amount</code> that will be withdrawn from the sender’s account balance. The right half of line 259 makes sure the sender has sufficient balance before line 261 adjusts it downwards by the total <code>amount</code> calculated earlier on line 257. Finally, line 262 starts a loop that performs the individual transfers by adjusting each receiver’s balance upward by <code>_value</code>.</p>

<p> </p>

<pre style="width: 825px"><code>255 function batchTransfer(address[] _receivers, uint256 _value) public whenNotPaused returns (bool) {
256   uint cnt = _receivers.length;
257   uint256 amount = uint256(cnt) * _value;
258   require(cnt &gt; 0 &amp;&amp; cnt &lt;= 20);
259   require(_value &gt; 0 &amp;&amp; balances[msg.sender] &gt;= amount);
260
261   balances[msg.sender] = balances[msg.sender].sub(amount);
262   for (uint i = 0; i &lt; cnt; i++) {
263     balances[_receivers[i]] = balances[_receivers[i]].add(_value);
264     Transfer(msg.sender, _receivers[i], _value);
265   }
266   return true;
267 }</code></pre>

<p> </p>

<p>One of the most common data types in Solidity is the unsigned 256-bit integer (<code>uint256</code> or <code>uint</code>) which can represent any value between 0 and 2<sup>256</sup>-1 inclusive. If contract code performs an ordinary arithmetic operation yielding a result outside this range, the result silently wraps around and contract execution continues with bad data – sometimes catastrophically. For this reason, the contract shown above specifically uses the specialized <code>.sub()</code> and <code>.add()</code> functions (on lines 261 and 263 respectively) from the SafeMath library we saw earlier. These <a href="https://medium.com/coinmonks/practicing-safemath-with-solidity-and-openzeppelin-cde4cba9ce39">common functions</a> are written to abort if an underflow or overflow is encountered, which will prevent execution from continuing with bad data. You might be asking why line 257 uses the ordinary <code>'*'</code> rather than <code>.mul()</code> from SafeMath…</p>

<p><strong>Bug!</strong> Regarding line 257, if <code>_value</code> were set to 2<sup>255</sup> and then doubled because of a <code>cnt</code> of two calculated on the prior line, the result would be stored into <code>amount</code> as 0 (rather than 2<sup>256</sup>) due to the wrap-around effect. This is the exact bug we are aiming to unpack – execution would now continue with bad data in play. The <code>_value</code> requested was huge but the total calculated <code>amount</code> is 0! The (bad) <code>amount</code> of 0 would then pass the balance check on line 259 and continue through the balance adjustment on line 261 just fine. However, the loop that performs the individual transfers utilizes the massive <code>_value</code> variable (with the <code>amount</code> variable no longer referenced). This means the loop would increase each of the two destination balances by 2<sup>255</sup>. Jackpot!</p>

<p><strong>What happened?</strong> An attacker called the <code>batchTransfer()</code> function shown above and provided it with a <code>_receivers</code> list containing two addresses and a <code>_value</code> parameter set to 2<sup>255</sup>. This can be clearly seen in <a href="https://etherscan.io/tx/0xad89ff16fd1ebe3a0a7cf4ed282302c06626c1af33221ebe0d3a470aba4a660f">the actual Etherscan transaction here</a> (click on ‘Decode Input Data’). As described, the <code>cnt</code> of addresses is calculated to be 2, so multiplying that with the <code>value</code> of 2<sup>255</sup> causes an overflow to an <code>amount</code> of 0. Execution continued onward with this bad data. The various checks pass, the sender’s balance is decreased by an <code>amount</code> of 0, and finally two massive deposits of <code>_value</code> are made into the <code>_receivers</code> balance. By the way, if you haven’t guessed it already, the large number referenced in the very first paragraph of this post happens to be 2<sup>255</sup>. For a real-money spend of approximately $0.02 USD to fund the attack transaction, two massive lots of tokens were created from thin air and deposited into the <code>_receiver</code> addresses. This resulted in the loss of trust in this token contract and thus completely devastated its value.</p>

<p><strong>Let’s fix it.</strong> All we have to do is replace the ordinary <code>'*'</code> on line 257 with <code>.mul()</code> as shown below. Lines prefixed with ‘–’ are to be removed from the contract code while those prefixed with ‘+’ are to be added.</p>

<p> </p>

<div class="sourceCode1" id="cb2"><pre class="sourceCode1 markdown"><code class="sourceCode1 markdown">- <span class="fl">   uint256 amount = uint256(cnt) * _value;</span>
<span class="fl">+    uint256 amount = uint256(cnt).mul(_value);</span></code></pre></div>

<p> </p>

<p><strong>Simple in retrospect?</strong> While almost all security bugs become obvious in retrospect, developers have been making these same mistakes for well over 20 years and continue to do so every day. Note that the above fix is moot for the BeautyChainToken, because there are no software updates for smart contracts. Once smart contracts are deployed they are essentially unchangeable and unstoppable beyond their original code. So our incredibly simple fix consisting of just a handful of characters can only be a lesson for the future, underscoring the theme of “do not allow arithmetic to silently go wrong and then continue execution with bad data”.</p>

<p><strong>Not so simple.</strong> Tokens were one of the first use cases for smart contracts and have been very carefully developed in the open by top experts. The presence of the SafeMath library demonstrates that this is a known problem area and the code we see above indeed makes use of it. In fact, the ERC-20 coin standard itself has several <a href="https://medium.com/@dexaran820/erc20-token-standard-critical-problems-3c10fd48657b">known problems</a> that remain only partially addressed (at best). Part of the challenge is that the development tool ecosystem is still emerging. <a href="https://www.comp.nus.edu.sg/~loiluu/papers/oyente.pdf">Formal methods and tools</a> are beginning to appear that will automatically find these issues. Unfortunately, it is still early days and smart contracts remain the Wild West for now.</p>

<p>The implosion of trust resulting from 2<sup>255</sup> tokens appearing out of thin air (twice) is hard to measure. We’ll run with $1M USD as a super conservative estimate that is roughly 1/20th the average funds raised in an <a href="https://cryptonews.com/news/on-average-an-ico-raised-29-more-this-year-excluding-telegra-1626.htm">Initial Coin Offering</a>. This brings our running total to $31M USD. Stay tuned, as there is always one more bug!</p>

    </div>
</div>
  
    <div class="card">
    <div class="card-header">
        <h2 id="smart-contract-insecurity----broken-access-control">Smart Contract (in)Security -- Broken Access Control</h2>
    </div>
    <ul class="card-subheader list-group list-group-flush">
       <li class="list-group-item">Written by <i class="fas fa-user"></i> Eric Schorn on <i class="fas fa-calendar"></i> 22 Sept 2018</li>
     </ul>
    <div class="card-content">
<p>This blog post is the first of a series that will describe some simple real-world <a href="https://www.investopedia.com/terms/s/smart-contracts.asp">smart contract</a> security bugs, how they were exploited, the resulting impacts and the corresponding code fixes. The series will cover more than $250M USD in losses directly attributable to smart contract security bugs.</p>
<p><strong>What are smart contracts?</strong> Imagine relatively short, publicly-accessible programs capable of owning large amounts of money and that execute complex transaction logic in an unchangeable and unstoppable fashion on a platform that is rapidly evolving alongside with its tools. Think blockchain 2.0 where transactions invoke code execution. These autonomous programs issue and manage private currencies, implement novel funding systems, tokenize capital assets, enable <a href="https://newalchemy.io/">new business models</a> and even breed digital cats called <a href="https://www.nytimes.com/2018/05/18/style/cryptokitty-auction.html">CryptoKitties</a>! There is no imagination required - the fascinating and flourishing world of smart contracts is already here with well over <a href="https://coinmarketcap.com/currencies/ethereum/">$1B USD of Ethereum changing hands daily</a>.</p>
<p><strong>Bugs are bad!</strong> One of the primary challenges limiting the progress of smart contract adoption is security. It is well known that &quot;every program always has one more bug&quot;, and <a href="http://sunnyday.mit.edu/accidents/MCO_report.pdf">some bugs can be catastrophic</a>. In the case of smart contracts, security bugs may exist wherever code behavior diverges from developer intent. This applies to both local low-level behavior through to the global system or social context (like <a href="https://www.investopedia.com/terms/f/frontrunning.asp">front-running</a>). Further, sometimes intent is stated and sometimes intent is unstated. Clearly, 'security' is a big, broad umbrella term in this application space.</p>
<p><a href="http://solidity.readthedocs.io/en/v0.4.24/">Solidity</a> is a new language created specifically for <a href="https://www.ethereum.org/">Ethereum</a>-based smart contracts and has many similarities to JavaScript, Java and C. Contracts are compiled to bytecode, embedded on the blockchain via a special transaction, and ultimately executed in the Ethereum Virtual Machine when stimulated by other transactions. As most security bugs are shockingly simple in retrospect, this blog series will not require deep expertise.</p>
<p><strong>The old is new again.</strong> This particular blog post will specifically cover <strong>broken access control</strong>. While smart contracts provide a <a href="http://dasp.co/#item-2">new context with unique novelties</a>, this is most certainly not a new problem. This topic can be found as item 5 in the <a href="https://www.owasp.org/index.php/Top_10-2017_A5-Broken_Access_Control">2017 Open Web Application Security Project (OWASP) Top 10</a> list of application security risks. Further, access control topics pervade the <a href="https://wiki.sei.cmu.edu/confluence/display/java/SEI+CERT+Oracle+Coding+Standard+for+Java">SEI CERT Oracle Coding Standard for Java</a> and vulnerabilities map to several Common Weakness Enumerations, <a href="https://cwe.mitre.org/data/definitions/284.html">including #284</a>. Smart contracts offer unique challenges related to their public execution environment, unchangeable nature, different stakeholder categories and high logical complexity.</p>
<p><strong>Show me the code.</strong> Consider the Solidity code below excerpted from the actual Parity Multisig Wallet contract intended to manage crypto-currency user accounts. The <a href="https://etherscan.io/address/0x91efffb9c6cd3a66474688d0a48aa6ecfe515aa5#code">actual deployed code</a>, warts and all, can be found via the public Etherscan block explorer. The first three function declarations (on lines 1, 6 and 16) shown below are key, with a glitch lurking in each. The <code>initWallet()</code> function is part of the initialization process intended to be executed once at contract creation. That function then calls <code>initMultiowned()</code> and <code>initDaylimit()</code> which deal with recording ownership details and transaction limits respectively. The fourth and last function declaration (line 21) shown below is perfectly fine, but might provide you with a small hint for what could go wrong...</p>

<p> </p>
<div class="sourceCode"><table class="sourceCode numberLines"><tr class="sourceCode"><td class="lineNumbers"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
</pre></td><td class="sourceCode"><pre><code class="sourceCode">function initWallet(address[] _owners, uint _required, uint _daylimit) {
    initMultiowned(_owners, _required);
    initDaylimit(_daylimit) ;
}

function initMultiowned(address[] _owners, uint _required) {
    m_numOwners = _owners.length ;
    m_required = _required;
    for (uint i = 0; i &lt; _owners.length; ++i)
    {
        m_owners[1 + i] = uint(_owners[i]);
        m_ownerIndex[uint(_owners[i])] = 1 + i;
    }
}

function initDaylimit(uint _limit) {
    m_dailyLimit = _limit;
    m_lastDay = today();
}

function execute(address _to, uint _value, bytes _data) onlyOwner returns(bool _callValue) {
    ... // execute transactions!
}</code></pre></td></tr></table></div>

<p><strong>Bug 1.</strong> The fourth and last function declaration (line 21) shown above includes the <code>onlyOwner</code> <a href="https://solidity.readthedocs.io/en/v0.4.24/contracts.html?highlight=modifier#function-modifiers">modifier</a> which acts as a gatekeeper, restricting the ability to invoke the <code>execute()</code> function to the contract owner. Here we see one of the primary purposes behind modifiers - they support <strong>access control</strong> on a granular per-function basis. Auditors (and hackers) will inspect each and every function for access control weaknesses via missing modifiers. Voila - the <code>initWallet()</code> function should similarly include a gatekeeper modifier that restricts the function execution to only when the contract is uninitialized (e.g. just once). There is no modifier here so the <code>initWallet()</code> function can be called repeatedly, with parameters from later invocations overwriting parameters from prior invocations. These parameters include the (new) address of the contract owner. Yes, ownership can be repeatedly changed! Hmmm...</p>
<p><strong>Bug 2.</strong> Furthermore, contract functions can also be constrained by having different <a href="https://solidity.readthedocs.io/en/v0.4.24/contracts.html?highlight=modifier#visibility-and-getters">visibility</a> modifiers such as <code>internal</code>, <code>external</code>, <code>public</code>, etc. The middle two function declarations (lines 6 and 16) above are part of an initialization scheme internal to the contract itself and so should be marked as <code>internal</code> which limits external accessibility. However, the visibility modifier is not specified here so it defaults to <code>public</code>. Yes, these functions can be called by anyone! Hmmm...</p>
<p><strong>What happened?</strong> An attacker called the <code>initWallet()</code> function shown above, transferred ownership to themselves and set a high day (transaction) limit. Etherscan clearly shows <a href="https://etherscan.io/tx/0xff261a49c61861884d0509dac46ed67577a7d48cb73c2f51f149c0bf96b29660">this transaction here</a>. Next, the attacker called the <code>execute()</code> function, now as the contract owner, to transfer Ethereum out of the contract and into their own account. Etherscan clearly shows this <a href="https://etherscan.io/address/0xb3764761e297d6f121e79c32a65829cd1ddb4d32">series of transactions here</a>, where individual transactions are at the bottom of the page and an account balance of $30M USD is shown near the top. Soon after this, two white-hat teams quickly stepped in to preemptively drain other accounts containing over $200M USD for subsequent return to the rightful owners.</p>
<p><strong>Let's fix it.</strong> The key issue boils down to an initialization function able to set ownership and that can unfortunately be called repeatedly by anyone. The visibility issue on the other two functions is related but ancillary - remember &quot;there is always one more bug&quot;. The corresponding fixes are not overly complicated and the <a href="https://github.com/paritytech/parity/commit/b640df8fbb964da7538eef268dffc125b081a82f">actual GitHub edits</a> are shown below. Lines prefixed with '--' have been removed from the contract code while those prefixed with '+' have been added. There are 4 parts to this fix.</p>

<div class="sourceCode"><table class="sourceCode numberLines"><tr class="sourceCode"><td class="lineNumbers"><pre>1
2
3
4
5
6
7
8
9
10
11
</pre></td><td class="sourceCode"><pre><code class="sourceCode">+  // throw unless the contract is not yet initialized.
+  modifier only_uninitialized { if (m_numOwners &gt; 0) throw; _; }

-  function initWallet(address[] _owners, uint _required, uint _daylimit) {
+  function initWallet(address[] _owners, uint _required, uint _daylimit) only_uninitialized {

-  function initMultiowned(address[] _owners, uint _required) {
+  function initMultiowned(address[] _owners, uint _required) internal {

-  function initDaylimit(uint _limit) {
+  function initDaylimit(uint _limit) internal {</code></pre></td></tr></table></div>

<p><strong>Simple in retrospect?</strong> First, a modifier named <code>only_uninitialized</code> is created on line 2 for subsequent use as a gatekeeper - it prevents execution by throwing an exception when the contract has already been initialized. Second, this modifier is applied to the <code>initWallet()</code> function on line 5 so that initialization can only be performed once. Finally, the <code>initMultiowned()</code> and <code>initDaylimit()</code> functions are marked with internal visibility on lines 8 and 11 so they cannot be called from outside the contract.</p>
<p><strong>Not so simple.</strong> The Parity Multisig Wallet was very carefully and methodically developed in the open with many, many expert eyeballs on it. A large part of the original motivation for developing it was to mitigate some of the risks associated with holding crypto-currencies. While the bug may look simple in retrospect, it still fell through the cracks and it wasn't the last bug. In this instance, it all boils down to broken access control in some novel circumstances. The lesson is to very carefully inspect function modifiers and function visibility for lurking weaknesses in access control.</p>
<p>Our running total now stands at $30M USD. Stay tuned, as there is always one more bug!</p>

    </div>
</div>
  


	<!-- /container -->
	</div>

	<!--Footer-->
	<footer class="page-footer font-small indigo pt-0" style="background-color:#4054b2;color:white">
	    <div class="container">
	        <div class="row">
	            <div class="col-md-12 py-5">
	                <div class="mb-5 flex-center" style="display:flex;align-items:center;justify-content:space-around;">
<!--
	                    <a>
	                        <i class="fab fa-ethereum fa-2x"></i>
	                    </a>
	                    <a>
	                        <i class="fab fa-ethereum fa-2x"></i>
	                    </a>-->
	                    <a>
	                        <i class="fab fa-ethereum fa-2x"></i>
	                    </a>

	                </div>
	            </div>
	        </div>
	    </div>

	    <div class="py-3 text-center" style="background-color:#33438e;">
	        <a href="https://www.nccgroup.trust" target="_blank">NCC Group</a> | <a href="https://cryptoservices.github.io/" target="_blank">Cryptography Services</a>
	    </div>

	</footer>
	<!--/Footer-->
	
	<!-- bootstrap.js -->
	<script src="https://code.jquery.com/jquery-3.2.1.slim.min.js" integrity="sha384-KJ3o2DKtIkvYIK3UENzmM7KCkRr/rE9/Qpg6aAZGJwFDMVNA/GpGFF93hXpG5KkN" crossorigin="anonymous"></script>
	<script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.12.9/umd/popper.min.js" integrity="sha384-ApNbgh9B+Y1QKtv3Rn7W3mgPxhU9K/ScQsAP7hUibX39j7fakFPskvXusvfa0b4Q" crossorigin="anonymous"></script>
	<script src="https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0/js/bootstrap.min.js" integrity="sha384-JZR6Spejh4U02d8jOt6vLEHfe/JQGiRRSQQxSfFWpi1MquVdAyjUar5+76PVCmYl" crossorigin="anonymous"></script>
	<!-- fontawesome.js -->
	<script defer src="https://use.fontawesome.com/releases/v5.0.8/js/all.js"></script>
	<!-- highlight.js -->
	<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
	<!-- script -->
	<script>
		// hljs.highlighting
		hljs.initHighlightingOnLoad();
	</script>
</body>
</html>