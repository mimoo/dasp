<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="utf-8">
	<title>
	DASP - TOP 10
</title>
	<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

	<!-- bootstrap.css -->
	<link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0/css/bootstrap.min.css" integrity="sha384-Gn5384xqQ1aoWXA+058RXPxPg6fy4IWvTNh0E263XmFcJlSAwiGgFAW/dAiS6JXm" crossorigin="anonymous">
	<!-- highlight code -->
	<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css">
	<!-- custom -->
	<link rel="stylesheet" href="styles.css">
	<!-- fontawesome.js -->
	<script defer src="https://use.fontawesome.com/releases/v5.0.8/js/all.js"></script>
	<!-- favicon stuff :/ -->
	<link rel="apple-touch-icon" sizes="57x57" href="favicon/apple-icon-57x57.png">
	<link rel="apple-touch-icon" sizes="60x60" href="favicon/apple-icon-60x60.png">
	<link rel="apple-touch-icon" sizes="72x72" href="favicon/apple-icon-72x72.png">
	<link rel="apple-touch-icon" sizes="76x76" href="favicon/apple-icon-76x76.png">
	<link rel="apple-touch-icon" sizes="114x114" href="favicon/apple-icon-114x114.png">
	<link rel="apple-touch-icon" sizes="120x120" href="favicon/apple-icon-120x120.png">
	<link rel="apple-touch-icon" sizes="144x144" href="favicon/apple-icon-144x144.png">
	<link rel="apple-touch-icon" sizes="152x152" href="favicon/apple-icon-152x152.png">
	<link rel="apple-touch-icon" sizes="180x180" href="favicon/apple-icon-180x180.png">
	<link rel="icon" type="image/png" sizes="192x192"  href="favicon/android-icon-192x192.png">
	<link rel="icon" type="image/png" sizes="32x32" href="favicon/favicon-32x32.png">
	<link rel="icon" type="image/png" sizes="96x96" href="favicon/favicon-96x96.png">
	<link rel="icon" type="image/png" sizes="16x16" href="favicon/favicon-16x16.png">
	<link rel="manifest" href="favicon/manifest.json">
	<meta name="msapplication-TileColor" content="#ffffff">
	<meta name="msapplication-TileImage" content="favicon/ms-icon-144x144.png">
	<meta name="theme-color" content="#ffffff">
</head>
<body data-spy="scroll" data-target="#top10">

	<!-- navbar -->
	<nav class="navbar navbar-expand-lg real navbar-light" style="margin-bottom:20px;">
		<a class="navbar-brand" href="/">
			<img src="ncc.png" alt="logo" style="width:100px">
		</a>
		<button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
			<span class="navbar-toggler-icon"></span>
		</button>

		<div class="collapse navbar-collapse" id="navbarSupportedContent">
			<ul class="navbar-nav mr-auto">
				<li class="nav-item active">
					<a class="nav-link" href="index.html">Top 10</a>
				</li>
				<li class="nav-item ">
					<a class="nav-link" href="articles.html">Articles</a>
				</li>
				<li class="nav-item ">
					<a class="nav-link" href="timeline.html">Timeline</a>
				</li>
				<li class="nav-item">
					<a class="nav-link" href="https://consensys.github.io/smart-contract-best-practices/" target="_blank">Best Practices</a>
				</li>
				<li>
					<a class="nav-link" href="https://github.com/nccgroup/GOATCasino" target="_blank">Capture The Flag</a>
				</li>
			</ul>
			<ul class="navbar-nav my-2 my-lg-0">
				<li class="nav-item">
					<a class="nav-link" data-toggle="modal" data-target="#aboutModal" href="#">About</a>
				</li>
				<li class="nav-item">
					<a class="nav-link" href="mailto:uscons-info@nccgroup.trust">Contact</a>
				</li>
				<li class="nav-item">
					<a class="nav-link" href="https://github.com/CryptoServices/dasp" target="_blank">Github</a>
				</li>
			</ul>
		</div>
	</nav>

	<!-- about modal -->
	<div id="aboutModal" class="modal" tabindex="-1" role="dialog" aria-labelledby="aboutModal" aria-hidden="true">
	  <div class="modal-dialog" role="document">
	    <div class="modal-content">
	      <div class="modal-header">
	        <h5 class="modal-title">About</h5>
	        <button type="button" class="close" data-dismiss="modal" aria-label="Close">
	          <span aria-hidden="true">&times;</span>
	        </button>
	      </div>
	      <div class="modal-body">
	        <p>This page was concocted by:</p>
        	<ul>
        		<li><a href="https://www.cryptologie.net" target="_blank">David Wong</a></li>
        		<li><a href="https://twitter.com/mah3mm" target="_blank">Mason Hemmel</a></li>
        	</ul>
	       	<p>We'd like to thank the following people for their precious help:</p>
	       	<ul>
	       		<li><a href="https://twitter.com/matthewdif" target="_blank">Matthew Di Ferrante</a></li>
	       	</ul>
	      </div>
	      <div class="modal-footer">
	        <button type="button" class="btn btn-secondary" data-dismiss="modal">Close</button>
	      </div>
	    </div>
	  </div>
	</div>

	<!-- container -->
	<div class="container">

		
<!-- message -->
<section class="welcome">
<!--	<h4 class="alert-heading"><i class="far fa-comment"></i> Welcome.</h4>-->
	<p>This is the very first iteration of the <i class="fab fa-ethereum"></i> <strong>Decentralized Application Security Project</strong> (or <strong>DASP</strong>) <strong>Top 10</strong> of <strong>2018</strong> </p>
	<hr>
	<p class="mb-0">This project is an initiative of <a href="https://www.nccgroup.trust" target="_blank">NCC Group</a>. It is an open and collaborative project to join efforts in discovering smart contract vulnerabilities within the security community. To get involved, <a href="https://github.com/CryptoServices/dasp" target="_blank">join the <i class="fab fa-github"></i> github page</a>.</p>
</section>

<!-- grid -->
<div class="row">
	<div class="col-3">

		<!-- aside navbar -->
		<nav id="top10" class="navbar navbar-dark bg-light d-none d-xl-block" style="position: -webkit-sticky;position: -moz-sticky;position: -ms-sticky;position: -o-sticky;position: sticky;top:15px;">
			<nav class="nav nav-pills flex-column">
				
				<a class="nav-link" href="#item-1">1. Reentrancy</a>
				
				<a class="nav-link" href="#item-2">2. Access Control</a>
				
				<a class="nav-link" href="#item-3">3. Arithmetic</a>
				
				<a class="nav-link" href="#item-4">4. Unchecked Low Level Calls</a>
				
				<a class="nav-link" href="#item-5">5. Denial of Services</a>
				
				<a class="nav-link" href="#item-6">6. Bad Randomness</a>
				
				<a class="nav-link" href="#item-7">7. Front Running</a>
				
				<a class="nav-link" href="#item-8">8. Time Manipulation</a>
				
				<a class="nav-link" href="#item-9">9. Short Addresses</a>
				
				<a class="nav-link" href="#item-10">10. Unknown Unknowns</a>
				
			</nav>
		</nav>

	</div>
	<div class="col">
		
		<article>
	<div class="container">
		<h1 class="display-4" id="item-1"><i class="fas fa-recycle fa-sm"></i> 1. Reentrancy</h1>
		<h5>also known as or related to <strong>race to empty</strong>, <strong>recursive call vulnerability</strong>, <strong>call to the unknown</strong></h5>
		<hr class="my-4">
<!--		<p class="lead">
			We believe more security audits or more tests would have made no difference. The main problem was that reviewers did not know what to look for.
			<footer class="blockquote-footer">Christoph Jentzsch</cite></footer>
		</p>-->
		<p class="lead">
		This exploit was missed in review so many times by so many different people: reviewers tend to review functions one at a time, and assume that calls to secure subroutines will operate securely and as intended.
			<footer class="blockquote-footer">Phil Daian</cite></footer>
		</p>
		<hr>
		<p>The Reentrancy attack, probably the most famous Ethereum vulnerability, surprised everyone when discovered for the first time. It was first unveiled during a multimillion dollar heist which led to a hard fork of Ethereum. Reentrancy occurs when external contract calls are allowed to make new calls to the calling contract before the initial execution is complete. For a function, this means that the contract state may change in the middle of its execution as a result of a call to an untrusted contract or the use of a low level function with an external address.</p>
		<p><strong>Loss</strong>: estimated at 3.5M ETH (~50M USD at the time)</p>
		<p><strong>Timeline of discovery</strong>:</p>

		<table class="table">
		  <thead class="thead-dark">
		    <tr>
		      <th scope="col">Date</th>
		      <th scope="col">Event</th>
		    </tr>
		  </thead>
		  <tbody>
		    <tr>
		      <th scope="row">Jun 5, 2016</th>
		      <td><a href="https://blog.ethereum.org/2016/06/10/smart-contract-security/">Christian Reitwiessner discovers an antipattern in solidity</a></td>
		    </tr>
		    <tr>
		    	<th scope="row">Jun 9, 2016</th>
		    	<td><a href="http://vessenes.com/more-ethereum-attacks-race-to-empty-is-the-real-deal/" target="_blank">More Ethereum Attacks: Race-To-Empty is the Real Deal (vessenes.com)</a></td>
		    </tr>
		    <tr>
		    	<th scope="row">Jun 12, 2016</th>
		    	<td><a href="https://blog.slock.it/no-dao-funds-at-risk-following-the-ethereum-smart-contract-recursive-call-bug-discovery-29f482d348b" target="_blank">No DAO funds at risk following the Ethereum smart contract ‘recursive call’ bug discovery (blog.slock.it)</a></td>
		    </tr>
		    <tr>
		    	<th scope="row">Jun 17, 2016</th>
		    	<td><a href="https://www.reddit.com/r/ethereum/comments/4oi2ta/i_think_thedao_is_getting_drained_right_now/">I think TheDAO is getting drained right now (reddit.com)</a></td>
		    </tr>
		    <tr>
		    	<th scope="row">Aug 24, 2016</th>
		    	<td><a href="https://blog.slock.it/the-history-of-the-dao-and-lessons-learned-d06740f8cfa5">The History of the DAO and Lessons Learned (blog.slock.it)</a></td>
		    </tr>
		  </tbody>
		</table>
		<p><strong>Real World Impact</strong>:</p>
		<ul>
			<li><a href="https://en.wikipedia.org/wiki/The_DAO_(organization)" target="_blank">The DAO</a></li>
		</ul>
		<p><strong>Example</strong>:</p>
		<ol>
			<li>A <span class="victim contract">smart contract</span> tracks the balance of a number of external addresses and allows users to retrieve funds with its public <code>withdraw()</code> function.</li>
			<li>A <span class="attacker contract">malicious smart contract</span> uses the <code>withdraw()</code> function to retrieve its entire balance.</li>
			<li>The <span class="victim contract">victim contract</span> executes the <code>call.value(amount)()</code> <strong>low level function</strong> to send the ether to the <span class="attacker contract">malicious contract</span> <strong>before updating the balance of the <span class="attacker contract">malicious contract</span></strong>. 
			<li>The <span class="attacker contract">malicious contract</span> has a payable <code>fallback()</code> function that accepts the funds and then calls back into the <span class="victim contract">victim contract</span>'s <code>withdraw()</code> function.</li>
			<li>This second execution triggers a transfer of funds: remember, the balance of the <span class="attacker contract">malicious contract</span> still hasn't been updated from the first withdrawal. As a result, the  <span class="attacker contract">malicious contract</span> successfully withdraws its entire balance a second time.</li>
		</ol>
		<p><strong>Code Example</strong>:</p>

		<p>The following function contains a function vulnerable to a reentrancy attack. When the low level <code>call()</code> function sends ether to the <code>msg.sender</code> address, it becomes vulnerable; if the address is a smart contract, the payment will trigger its fallback function with what's left of the transaction gas:</p>

<pre><code>function withdraw(uint _amount) {
	require(balances[msg.sender] >= _amount);
	msg.sender.call.value(_amount)();
	balances[msg.sender] -= _amount;
}</code></pre>

		<p><strong>Additional Resources</strong>:</p>
		<ul>
			<li><a href="https://etherscan.io/address/0xbb9bc244d798123fde783fcc1c72d3bb8c189413#code" target="_blank">The DAO smart contract</a></li>
			<li><a href="http://hackingdistributed.com/2016/06/18/analysis-of-the-dao-exploit/" target="_blank">Analysis of the DAO exploit</a></li>
			<li><a href="http://blockchain.unica.it/projects/ethereum-survey/attacks.html#simpledao" target="_blank">Simple DAO code example</a></li>
			<li><a href="https://github.com/trailofbits/not-so-smart-contracts/tree/master/reentrancy" target="_blank">Reentrancy code example</a></li>
			<li><a href="https://blog.citymayor.co/posts/how-someone-tried-to-exploit-a-flaw-in-our-smart-contract-and-steal-all-of-its-ether/" target="_blank">How Someone Tried to Exploit a Flaw in Our Smart Contract and Steal All of Its Ether</a></li>
		</ul>
	</div>
</article>
		
		<article>
	<div class="container">
		<!-- title -->
		<h1 class="display-4" id="item-2"><i class="fas fa-id-card fa-sm"></i> 2. Access Control</h1>
		<hr class="my-4">
		<!-- quote -->
		<p class="lead">
			It was possible to turn the Parity Wallet library contract into a regular multi-sig wallet and become an owner of it by calling the initWallet function.
			<footer class="blockquote-footer">Parity</cite></footer>
		</p>
		<hr>
		<!-- description -->
		<p>Access Control issues are common in all programs, not just smart contracts. In fact, it's <a href="https://www.owasp.org/images/7/72/OWASP_Top_10-2017_%28en%29.pdf.pdf" target="_blank">number 5 on the OWASP top 10</a>. One usually accesses a contract's functionality through its public or external functions. While insecure <strong>visibility</strong> settings give attackers straightforward ways to access a contract's private values or logic, access control bypasses are sometimes more subtle. These vulnerabilities can occur when contracts use the deprecated <code>tx.origin</code> to validate callers, handle large authorization logic with lengthy <code>require</code> and make reckless use of <code>delegatecall</code> in <a href="https://blog.zeppelin.solutions/proxy-libraries-in-solidity-79fbe4b970fd" target="_blank">proxy libraries</a> or <a href="https://blog.indorse.io/ethereum-upgradeable-smart-contract-strategies-456350d0557c" target="_blank">proxy contracts</a>.</p>
		<p><strong>Loss</strong>: estimated at 150,000 ETH (~30M USD at the time)</p>
		<!-- real world impact -->
		<p><strong>Real World Impact</strong>:</p>
		<ul>
			<li><a href="http://paritytech.io/the-multi-sig-hack-a-postmortem/" target="_blank">Parity Multi-sig bug 1</a></li>
			<li><a href="http://paritytech.io/a-postmortem-on-the-parity-multi-sig-library-self-destruct/" target=""_blank">Parity Multi-sig bug 2</a></li>
			<li><a href="https://blog.ethereum.org/2016/06/19/thinking-smart-contract-security/" target="_blank">Rubixi</a></li>
		</ul>
		<!-- example scenario -->
		<p><strong>Example</strong>:</p>
		<ol>
			<li>A <span class="contract victim">smart contract</span> designates the address which initializes it as the contract's owner. This is a common pattern for granting special privileges such as the ability to withdraw the contract's funds.</li>
			<li>Unfortunately, the initialization function can be called by anyone &mdash; even after it has already been called. Allowing anyone to become the owner of the contract and take its funds.</li>
		</ol>
		<!-- code examples -->
		<p><strong>Code Example</strong>:</p>
		<p>In the following example, the contract's <strong>initialization function</strong> sets the caller of the function as its owner. However, the logic is detached from the contract's constructor, and it does not keep track of the fact that it has already been called.</p>
<pre><code>function initContract() public {
	owner = msg.sender;
}</code></pre>
		<p>In the Parity multi-sig wallet, this initialization function was detached from the wallets themselves and defined in a "library" contract. Users were expected to initialize their own wallet by calling the library's function via a <code>delegateCall</code>. Unfortunately, as in our example, the function did not check if the wallet had already been initialized. Worse, since the library was a smart contract, anyone could initialize the library itself and call for its destruction.</p>
		<!-- additional resources -->
		<p><strong>Additional Resources</strong>:</p>
		<ul>
			<li><a href="https://github.com/paritytech/parity/pull/6103/files" target="_blank">Fix for Parity multi-sig wallet bug 1</a></li>
			<li><a href="http://paritytech.io/security-alert-2/" target="_blank">Parity security alert 2</a></li>
			<li><a href="https://blog.zeppelin.solutions/on-the-parity-wallet-multisig-hack-405a8c12e8f7" target="_blank">On the Parity wallet multi-sig hack</a></li>
			<li><a href="https://github.com/trailofbits/not-so-smart-contracts/tree/master/unprotected_function" target="_blank">Unprotected function</a></li>
			<li><a href="https://etherscan.io/address/0xe82719202e5965Cf5D9B6673B7503a3b92DE20be#code" target="_blank">Rubixi's smart contract</a></li>
		</ul>
	</div>
</article>
		
		<article>
	<div class="container">
		<!-- title -->
		<h1 class="display-4" id="item-3"><i class="fas fa-sort-numeric-up fa-sm"></i> 3. Arithmetic Issues</h1>
		<!-- alternate names -->
		<h5>also known as <strong>integer overflow</strong> and <strong>integer underflow</strong></h5>
		<hr class="my-4">
		<!-- quote -->
		<p class="lead">An overflow condition gives incorrect results and, particularly if the possibility has not been anticipated, can compromise a program’s reliability and security.
			<footer class="blockquote-footer">Jules Dourlens</cite></footer>
		</p>
		<hr>
		<!-- description -->
		<p>Integer overflows and underflows are not a new class of vulnerability, but they are especially dangerous in smart contracts, where unsigned integers are prevalent and most developers are used to simple <code>int</code> types (which are often just signed integers). If overflows occur, many benign-seeming codepaths become vectors for theft or denial of service.</p>
		<!-- real world impact -->
		<p><strong>Real World Impact</strong>:</p>
		<ul>
			<li><a href="http://blockchain.unica.it/projects/ethereum-survey/attacks.html" target="_blank">The DAO</a></li>
			<li><a href="https://peckshield.com/2018/04/22/batchOverflow/">BatchOverflow (multiple tokens)</a></li>
			<li><a href="https://peckshield.com/2018/04/25/proxyOverflow/">ProxyOverflow (multiple tokens)</a></li>
		</ul>
		<!-- example scenario -->
		<p><strong>Example</strong>:

		<ol>
			<li>A <span class="contract victim">smart contract</span>'s <code>withdraw()</code> function allows you to retrieve ether donated to the contract as long as your balance remains positive after the operation.</li>
			<li>An <span class="contract attacker">attacker</span> attempts to withdraw more than his or her current balance.</li>
			<li>The <code>withdraw()</code> function check's result is always a positive amount, allowing the attacker to withdraw more than allowed. The resulting balance underflows and becomes an order of magnitude larger than it should be.</li>
		</ol>


		<!-- code examples -->
		<p><strong>Code Example</strong>:</p>

		<p>The most straightforward example is a function that does not check for integer underflow, allowing you to withdraw an infinite amount of tokens:</p>

<pre><code>function withdraw(uint _amount) {
	require(balances[msg.sender] - _amount > 0);
	msg.sender.transfer(_amount);
	balances[msg.sender] -= _amount;
}</code></pre>

		<p>The second example (spotted during the <a href="https://github.com/Arachnid/uscc/tree/master/submissions-2017/doughoyte" target="_blank">Underhanded Solidity Coding Contest</a>) is an off-by-one error facilitated by the fact that an array's length is represented by an unsigned integer:</p>

<pre><code>function popArrayOfThings() {
	require(arrayOfThings.length >= 0);
	arrayOfThings.length--; 
}</code></pre>

		<p>The third example is a variant of the first example, where the result of arithmetic on two unsigned integers is an unsigned integer:</p>

<pre><code>function votes(uint postId, uint upvote, uint downvotes) {
	if (upvote - downvote < 0) {
		deletePost(postId)
	}
}</code></pre>

		<p>The fourth example features the soon-to-be-deprecated <code>var</code> keyword. Because <code>var</code> will change itself to the smallest type needed to contain the assigned value, it will become an <code>uint8</code> to hold the value 0. If the loop is meant to iterate more than 255 times, it will never reach that number and will stop when the execution runs out of gas:</p>

<pre><code>for (var i = 0; i < somethingLarge; i ++) {
	// ...
}</code></pre>

		<!-- additional resources -->
		<p><strong>Additional Resources</strong>:</p>
		<ul>
			<li><a href="https://ethereumdev.io/safemath-protect-overflows/" target="_blank">SafeMath to protect from overflows</a></li>
			<li><a href="https://github.com/trailofbits/not-so-smart-contracts/tree/master/integer_overflow" target="_blank">Integer overflow code example</a></li>
		</ul>
	</div>
</article>
		
		<article>
	<div class="container">
		<!-- title -->
		<h1 class="display-4" id="item-4"><i class="fas fa-check fa-sm"></i> 4. Unchecked Return Values For Low Level Calls</h1>
		<h5>also known as or related to <strong>silent failing sends</strong>, <strong>unchecked-send</strong></h5>

		<hr class="my-4">
		<!-- quote -->
		<p class="lead">
			The use of low level "call" should be avoided whenever possible. It can lead to unexpected behavior if return values are not handled properly.
			<footer class="blockquote-footer">Remix</cite></footer>
		</p>
		<hr>
		<!-- description -->
		<p>One of the deeper features of Solidity are the low level functions <code>call()</code>, <code>callcode()</code>, <code>delegatecall()</code> and <code>send()</code>. Their behavior in accounting for errors is quite different from other Solidity functions, as they will not propagate (or bubble up) and will not lead to a total reversion of the current execution. Instead, they will return a boolean value set to <code>false</code>, and the code will continue to run. This can surprise developers and, if the return value of such low-level calls are not checked, can lead to fail-opens and other unwanted outcomes. Remember, <strong>send can fail!</strong></p>
		<!-- real world impact -->
		<p><strong>Real World Impact</strong>:</p>
		<ul>
			<li><a href="https://www.kingoftheether.com/postmortem.html" target="_blank">King of the Ether</a></li>
			<li><a href="http://aakilfernandes.github.io/blockhashes-are-only-good-for-256-blocks" target="_blank">Etherpot</a></li>
		</ul>
		<!-- example scenario -->
<!--		<p><strong>Example</strong>:</p>
		<ol>
		</ol> -->
		<!-- code examples -->
		<p><strong>Code Example</strong>:</p>
		<p>The following code is an example of what can go wrong when one forgets to check the return value of <code>send()</code>. If the call is used to send ether to a smart contract that does not accept them (e.g. because it does not have a <strong>payable</strong> fallback function), the EVM will replace its return value with <code>false</code>. Since the return value is not checked in our example, the function's changes to the contract state will not be reverted, and the <code>etherLeft</code> variable will end up tracking an incorrect value:</p>
<pre><code>function withdraw(uint256 _amount) public {
	require(balances[msg.sender] >= _amount);
	balances[msg.sender] -= _amount;
	etherLeft -= _amount;
	msg.sender.send(_amount);
}</code></pre>
		<!-- additional resources -->
		<p><strong>Additional Resources</strong>:</p>
		<ul>
			<li><a href="https://github.com/trailofbits/not-so-smart-contracts/tree/master/unchecked_external_call" target="_blank">Unchecked external call</a></li>
			<li><a href="http://hackingdistributed.com/2016/06/16/scanning-live-ethereum-contracts-for-bugs/" target="_blank">Scanning Live Ethereum Contracts for the "Unchecked-Send" Bug</a></li>
		</ul>
	</div>
</article>
		
		<article>
	<div class="container">
		<!-- title -->
		<h1 class="display-4" id="item-5"><i class="fas fa-ban fa-sm"></i> 5. Denial of Service</h1>
		<!-- alternate names -->
		<h5>including <strong>gas limit reached</strong>, <strong>unexpected throw</strong>, <strong>unexpected kill</strong>, <strong>access control breached</strong></h5>
		<hr class="my-4">
		<!-- quote -->
		<p class="lead">
			I accidentally killed it.
			<footer class="blockquote-footer"><a href="https://github.com/paritytech/parity/issues/6995" target="_blank">devops199 on the Parity multi-sig wallet</a></cite></footer>
		</p>
		<hr>
		<!-- description -->
		<p>Denial of service is deadly in the world of Ethereum: while other types of applications can eventually recover, smart contracts can be taken offline forever by just one of these attacks. Many ways lead to denials of service, including maliciously behaving when being the recipient of a transaction,  artificially increasing the gas necessary to compute a function, abusing access controls to access private components of smart contracts, taking advantage of mixups and negligence, etc. This class of attack includes many different variants and will probably see a lot of development in the years to come.</p>
		<!-- numbers if loss occured -->
		<p><strong>Loss</strong>: estimated at 514,874 ETH (~300M USD at the time)</p>
		<!-- real world impact -->
		<p><strong>Real World Impact</strong>:</p>
		<ul>
			<li><a href="https://www.reddit.com/r/ethereum/comments/4ghzhv/governmentals_1100_eth_jackpot_payout_is_stuck/" target="_blank">GovernMental</a></li>
			<li><a href="http://paritytech.io/a-postmortem-on-the-parity-multi-sig-library-self-destruct/">Parity Multi-sig wallet</a></li>
		</ul>
		<!-- example scenario -->
		<!-- (1) gas limit (2) unexpected throw (3) money tracking issues (escrowed, sent on suicide). (4) logic calls into attacker controlled addresses (unpayable fallbacks) (4) negligence will place kill switch in public libraries (parity) -->
		<p><strong>Example</strong>:</p>
		<ol>
			<li>An <span class="contract victim">auction contract</span> allows its users to bid on different assets.</li>
			<li>To bid, a user must call a <code>bid(uint object)</code> function with the desired amount of ether. The auction contract will store the ether in <strong>escrow</strong> until the object's owner accepts the bid or the initial bidder cancels it. This means that the auction contract must hold the full value of any unresolved bid in its balance.</li>
			<li>The <span class="contract victim">auction contract</span> also contains a <code>withdraw(uint amount)</code> function which allows admins to retrieve funds from the contract. As the function sends the <code>amount</code> to a hardcoded address, the developers have decided to make the function public.</li>
			<li>An <span class="contract attacker">attacker</span> sees a potential attack and calls the function, directing all the <span class="contract victim">contract</span>'s funds to its admins. This destroys the promise of escrow and blocks all the pending bids.</li>
			<li> While the admins might return the escrowed money to the contract, the <span class="contract attacker">attacker</span> can continue the attack by simply withdrawing the funds again.</li>
		</ol>
		<!-- code examples -->
		<p><strong>Code Example</strong>:</p>

		<p>In the following example (inspired by <a href="http://blockchain.unica.it/projects/ethereum-survey/attacks.html#kotet">King of the Ether</a>) a function of a game contract allows you to become the president if you publicly bribe the previous one. Unfortunately, if the previous president is a smart contract and causes reversion on payment, the transfer of power will fail and the malicious smart contract will remain president forever. Sounds like a dictatorship to me:</p>

<pre><code>function becomePresident() payable {
    require(msg.value >= price); // must pay the price to become president
    president.transfer(price);   // we pay the previous president
    president = msg.sender;      // we crown the new president
    price = price * 2;           // we double the price to become president
}</code></pre>

		<p>In this second example, a caller can decide who the next function call will reward. Because of the expensive instructions in the <code>for</code> loop, an attacker can introduce a number too large to iterate on (due to gas block limitations in Ethereum) which will effectively block the function from functioning.</p>

<pre><code>function selectNextWinners(uint256 _largestWinner) {
	for(uint256 i = 0; i < largestWinner, i++) {
		// heavy code
	}
	largestWinner = _largestWinner;
}</code></pre>

		<!-- additional resources -->
		<p><strong>Additional Resources</strong>:</p>
		<ul>
			<li><a href="https://medium.com/chain-cloud-company-blog/parity-multisig-hack-again-b46771eaa838">Parity Multisig Hacked. Again</a></li>
			<li><a href="https://blog.artoken.io/statement-on-the-parity-multi-sig-wallet-vulnerability-and-the-cappasity-artoken-crowdsale-b3a3fed2d567">Statement on the Parity multi-sig wallet vulnerability and the Cappasity token crowdsale</a></li>
		</ul>
	</div>
</article>
		
		<article>
	<div class="container">
		<!-- title -->
		<h1 class="display-4" id="item-6"><i class="far fa-hand-scissors"></i> 6. Bad Randomness</h1>
		<!-- alternate names -->
		<h5>also known as <strong>nothing is secret</strong></h5>
		<hr class="my-4">
		<!-- quote -->
		<p class="lead">
			The contract had insufficient validation of the block.number age, which resulted in 400 ETH being lost to an unknown player who waited for 256 blocks before revealing the predictable winning number.
			<footer class="blockquote-footer">Arseny Reutov</cite></footer>
		</p>
		<hr>
		<!-- description -->
		<p>Randomness is hard to get right in Ethereum. While Solidity offers <a href="http://solidity.readthedocs.io/en/v0.4.21/units-and-global-variables.html" target="_blank">functions and variables</a> that can access apparently hard-to-predict values, they are generally either more public than they seem or subject to miners' influence. Because these sources of randomness are to an extent predictable, malicious users can generally replicate it and attack the function relying on its unpredictablility.</p>
		<!-- numbers if loss occured -->
		<p><strong>Loss</strong>: more than 400 ETH</p>
		<!-- real world impact -->
		<p><strong>Real World Impact</strong>:</p>
		<ul>
			<li><a href="https://www.reddit.com/r/ethereum/comments/74d3dc/smartbillions_lottery_contract_just_got_hacked/" target="_blank">SmartBillions Lottery</a></li>
			<li><a href="https://medium.com/@hrishiolickel/why-smart-contracts-fail-undiscovered-bugs-and-what-we-can-do-about-them-119aa2843007" target="_blank">TheRun</a></li>
		</ul>
		<!-- example scenario -->
		<p><strong>Example</strong>:</p>
		<ol>
			<li>A <span class="contract victim">smart contract</span> uses the block number as a source of randomness for a game.</li>
			<li>An attacker creates a <span class="contract attacker">malicious contract</span> that checks if the current block number is a winner. If so, it calls the first <span class="contract victim">smart contract</span> in order to win; since the call will be part of the same transaction, the block number will remain the same on both contracts.</li>
			<li>The attacker only has to call her <span class="contract attacker">malicious contract</span> until it wins.</li>
		</ol>
		<!-- code examples -->
		<p><strong>Code Example</strong>:</p>
		<p>In this first example, a <code>private seed</code> is used in combination with an <code>iteration</code> number and the <code>keccak256</code> hash function to determine if the caller wins. Even though the <code>seed</code> is <code>private</code>, it must have been set via a transaction at some point in time and thus is visible on the blockchain.</p>
<pre><code>uint256 private seed;

function play() public payable {
	require(msg.value >= 1 ether);
	iteration++;
	uint randomNumber = uint(keccak256(seed + iteration));
	if (randomNumber % 2 == 0) {
		msg.sender.transfer(this.balance);
	}
}</code></pre>
		<p>In this second example, <code>block.blockhash</code> is being used to generate a random number. This hash is unknown if the <code>blockNumber</code> is set to the current <code>block.number</code> (for obvious reasons), and is thus set to <code>0</code>. In the case where the <code>blockNumber</code> is set to more than 256 blocks in the past, it will always be zero. Finally, if it is set to a previous block number that is not too old, another smart contract can access the same number and call the game contract as part of the same transaction.</p>

<pre><code>function play() public payable {
	require(msg.value >= 1 ether);
	if (block.blockhash(blockNumber) % 2 == 0) {
		msg.sender.transfer(this.balance);
	}
}</code></pre>
		<!-- additional resources -->
		<p><strong>Additional Resources</strong>:</p>
		<ul>
			<li><a href="https://blog.positive.com/predicting-random-numbers-in-ethereum-smart-contracts-e5358c6b8620">Predicting Random Numbers in Ethereum Smart Contracts</a></li>
			<li><a href="https://blog.otlw.co/random-in-ethereum-50eefd09d33e" target="_blank">Random in Ethereum</a></li>
		</ul>
	</div>
</article>
		
		<article>
	<div class="container">
		<!-- title -->
		<h1 class="display-4" id="item-7"><i class="fas fa-random fa-sm"></i> 7. Front-Running</h1>
		<!-- alternate names -->
		<h5>also known as <strong>time-of-check vs time-of-use (TOCTOU)</strong>, <strong>race condition</strong>, <strong>transaction ordering dependence (TOD)</strong></h5>
		<hr class="my-4">
		<!-- quote -->
		<p class="lead">
			Turns out, all it takes is about 150 lines of Python to get a working front-running algorithm. 
			<footer class="blockquote-footer">Ivan Bogatyy</cite></footer>
		</p>
		<hr>
		<!-- description -->
		<p>Since miners always get rewarded via gas fees for running code on behalf of externally owned addresses (EOA), users can specify higher fees to have their transactions mined more quickly. Since the Ethereum blockchain is public, everyone can see the contents of others' pending transactions. This means if a given user is revealing the solution to a puzzle or other valuable secret, a malicious user can steal the solution and copy their transaction with higher fees to preempt the original solution. If developers of smart contracts are not careful, this situation can lead to practical and devastating front-running attacks. <!-- this attack is so surprising that even ERC-20 is vulnerable to it --></p>
		<!-- numbers if loss occured -->
<!--		<p><strong>Loss</strong>: unknown</p>-->
		<!-- real world impact -->
		<p><strong>Real World Impact</strong>:</p>
		<ul>
			<li><a href="https://hackernoon.com/front-running-bancor-in-150-lines-of-python-with-ethereum-api-d5e2bfd0d798" target="_blank">Bancor</a></li>
			<li><a href="https://docs.google.com/document/d/1YLPtQxZu1UAvO9cZ1O2RPXBbT0mooh4DYKjA_jp-RLM/" target="_blank">ERC-20</a></li>
			<li><a href="">TheRun</a></li>
		</ul>
		<!-- example scenario -->
		<p><strong>Example</strong>:</p>
		<ol>
			<li>A <span class="victim contract">smart contract</span> publishes an RSA number (<code>N = prime1 x prime2</code>).</li>
			<li>A call to its <code>submitSolution()</code> public function with the right <code>prime1</code> and <code>prime2</code> rewards the caller.</li>
			<li>Alice successfuly factors the RSA number and submits a solution.</li>
			<li><span class="contract attacker">Someone</span> on the network sees Alice's transaction (containing the solution) waiting to be mined and submits it with a higher gas price.</li>
			<li>The second transaction gets picked up first by miners due to the higher paid fee. The <span class="contract attacker">attacker</span> wins the prize.</li>
		</ol>
		<!-- additional resources -->
		<p><strong>Additional Resources</strong>:</p>
		<ul>
			<li><a href="https://blog.positive.com/predicting-random-numbers-in-ethereum-smart-contracts-e5358c6b8620" target="_blank">Predicting random numbers in Ethereum smart contracts</a></li>
			<li><a href="https://blog.0xproject.com/front-running-griefing-and-the-perils-of-virtual-settlement-part-1-8554ab283e97" target="_blank">Front-running, Griefing and the Perils of Virtual Settlement</a></li>
			<li><a href="https://www.youtube.com/watch?v=RL2nE3huNiI" target="_blank">Frontrunning Bancor</a></li>
		</ul>
	</div>
</article>
		
		<article>
	<div class="container">
		<!-- title -->
		<h1 class="display-4" id="item-8"><i class="fas fa-clock fa-sm"></i> 8. Time manipulation</h1>
		<!-- alternate names -->
		<h5>also known as <strong>timestamp dependence</strong></h5>
		<hr class="my-4">
		<!-- quote -->
		<p class="lead">
			If a miner holds a stake on a contract, he could gain an advantage by choosing a suitable timestamp for a block he is mining.
			<footer class="blockquote-footer">Nicola Atzei, Massimo Bartoletti and Tiziana Cimoli</cite></footer>
		</p>
		<hr>
		<!-- description -->
		<p>From locking a token sale to unlocking funds at a specific time for a game, contracts sometimes need to rely on the current time. This is usually done via <code>block.timestamp</code> or its alias <code>now</code> in Solidity. But where does that value come from? From the miners! Because a transaction's miner has leeway in reporting the time at which the mining occurred, good smart contracts will avoid relying strongly on the time advertised. Note that <code>block.timestamp</code> is also sometimes (mis)used in the generation of random numbers as is discussed in <a href="#item-6">#6. Bad Randomness</a>.</p>
		<!-- real world impact -->
		<p><strong>Real World Impact</strong>:</p>
		<ul>
			<li><a href="http://blockchain.unica.it/projects/ethereum-survey/attacks.html#governmental" target="_blank">GovernMental</a></li>
		</ul>
		<!-- example scenario -->
		<p><strong>Example</strong>:</p>
		<ol>
			<li>A <span class="contract victim">game</span> pays out the very first player at midnight today.</li>
			<li>A malicious <span class="contract attacker">miner</span> includes his or her attempt to win the game and sets the timestamp to midnight.</li>
			<li>A bit before midnight the miner ends up mining the block. The real current time is "close enough" to midnight (the currently set timestamp for the block), other nodes on the network decide to accept the block.</li>
		</ol>
		<!-- code examples -->
		<p><strong>Code Example</strong>:</p>
		<p>The following function only accepts calls that come after a specific date. Since miners can influence their block's timestamp (to a certain extent), they can attempt to mine a block containing their transaction with a block timestamp set in the future. If it is close enough, it will be accepted on the network and the transaction will give the miner ether before any other player could have attempted to win the game:</p>
<pre><code>function play() public {
	require(now > 1521763200 && neverPlayed == true);
	neverPlayed = false;
	msg.sender.transfer(1500 ether);
}</code></pre>
		<!-- additional resources -->
		<p><strong>Additional Resources</strong>:</p>
		<ul>
			<li><a href="https://eprint.iacr.org/2016/1007" target="_blank">A survey of attacks on Ethereum smart contracts</a></li>
			<li><a href="https://blog.positive.com/predicting-random-numbers-in-ethereum-smart-contracts-e5358c6b8620" target="_blank">Predicting Random Numbers in Ethereum Smart Contracts</a></li>
			<li><a href="https://blog.acolyer.org/2017/02/23/making-smart-contracts-smarter/" target="_blank">Making smart contracts smarter</a></li>
		</ul>
	</div>
</article>
		
		<article>
	<div class="container">
		<!-- title -->
		<h1 class="display-4" id="item-9"><i class="fas fa-sort-amount-down fa-sm"></i> 9 Short Address Attack</h1>
		<!-- alternate names -->
		<h5>also known as or related to <strong>off-chain issues</strong>, <strong>client vulnerabilities</strong></h5>
		<hr class="my-4">
		<!-- quote -->
		<p class="lead">
			The service preparing the data for token transfers assumed that users will input 20-byte long addresses, but the length of the addresses was not actually checked. 
			<footer class="blockquote-footer">Paweł Bylica</cite></footer>
		</p>
		<hr>
		<!-- description -->
		<p>Short address attacks are a side-effect of the EVM itself accepting incorrectly padded arguments. Attackers can exploit this by using specially-crafted addresses to make poorly coded clients encode arguments incorrectly before including them in transactions. Is this an EVM issue or a client issue? Should it be fixed in smart contracts instead? While everyone has a different opinion, the fact is that a great deal of ether could be directly impacted by this issue. While this vulnerability has yet to be exploited in the wild, it is a good demonstration of problems arising from the interaction between clients and the Ethereum blockchain. Other off-chain issues exist: an important one is the Ethereum ecosystem's deep trust in specific Javascript front ends, browser plugins and public nodes. An infamous off-chain exploit was used in <a href="https://medium.com/crypt-bytes-tech/ico-hack-coindash-ed-dd336a4f1052">the hack of the Coindash ICO</a> that modified the company's Ethereum address on their webpage to trick participants into sending ethers to the attacker's address.</p>
		<!-- timeline of events -->
		<p><strong>Timeline of discovery</strong>:</p>
		<table class="table">
		  <thead class="thead-dark">
		    <tr>
		      <th scope="col">Date</th>
		      <th scope="col">Event</th>
		    </tr>
		  </thead>
		  <tbody>
		    <tr>
		      <th scope="row">April 6, 2017</th>
		      <td><a href="https://medium.com/golem-project/how-to-find-10m-by-just-reading-blockchain-6ae9d39fcd95">How to Find $10M Just by Reading the Blockchain</a></td>
		    </tr>
		  </tbody>
		</table>
		<!-- real world impact -->
		<p><strong>Real World Impact</strong>:</p>
		<ul>
			<li><a href="https://medium.com/golem-project/how-to-find-10m-by-just-reading-blockchain-6ae9d39fcd95" target="_blank">unknown exchange(s)</a></li>
		</ul>
		<!-- example scenario -->
		<p><strong>Example</strong>:</p>
		<ol>
			<li>An exchange API has a trading function that takes a recipient address and an amount.</li>
			<li>The API then interacts with the smart contract <code>transfer(address _to, uint256 _amount)</code> function with padded arguments: it prepends the address (of an expected 20-byte length) with 12 zero bytes to make it 32-byte long</li>
			<li>Bob (<code>0x3bdde1e9fbaef2579dd63e2abbf0be445ab93f<strong>00</strong></code>) asks Alice to transfer him 20 tokens. He maliciously gives her his address truncated to remove the trailing zeroes.</li>
			<li>Alice uses the exchange API with the shorter 19-byte address of Bob (<code>0x3bdde1e9fbaef2579dd63e2abbf0be445ab93f</code>).</li>
			<li>The API pads the address with 12 zero bytes, making it 31 bytes instead of the 32 bytes. Effectively stealing one byte from the following <code>_amount</code> argument.</li>
			<li>Eventually, the EVM executing the smart contract's code will remark that the data is not properly padded and will add the missing byte at the end of the <code>_amount</code> argument. Effectively transfering 256 times more tokens than thought.</li>
		</ol>
		<!-- additional resources -->
		<p><strong>Additional Resources</strong>:</p>
		<ul>
			<li><a href="http://vessenes.com/the-erc20-short-address-attack-explained/" target="_blank">The ERC20 Short Address Attack Explained</a></li>
			<li><a href="https://ericrafaloff.com/analyzing-the-erc20-short-address-attack/" target="_blank">Analyzing the ERC20 Short Address Attack</a></li>
			<li><a href="https://blog.coinfabrik.com/smart-contract-short-address-attack-mitigation-failure/" target="_blank">Smart Contract Short Address Attack Mitigation Failure</a></li>
			<li><a href="https://github.com/OpenZeppelin/zeppelin-solidity/issues/261" target="_blank">Remove short address attack checks from tokens</a></li>
		</ul>
	</div>
</article>
		
		<article>
	<div class="container">
		<!-- title -->
		<h1 class="display-4" id="item-10"><i class="far fa-question-circle fa-sm"></i> 10. Unknown Unknowns</h1>
		<hr class="my-4">
		<!-- quote -->
		<p class="lead">
			We believe more security audits or more tests would have made no difference. The main problem was that reviewers did not know what to look for.
			<footer class="blockquote-footer">Christoph Jentzsch</cite></footer>
		</p>
		<hr>
		<!-- description -->
		<p>Ethereum is still in its infancy. The main language used to develop smart contracts, Solidity, has yet to reach a stable version and the ecosystem's tools are still experimental. Some of the most damaging smart contract vulnerabilities surprised everyone, and there is no reason to believe there will not be another one that will be equally unexpected or equally destructive. As long as investors decide to place large amounts of money on complex but lightly-audited code, we will continue to see new discoveries leading to dire consequences. Methods of formally verifying smart contracts are not yet mature, but they seem to hold great promise as ways past today's shaky status quo. As new classes of vulnerabilities continue to be found, developers will need to stay on their feet, and new tools will need to be developed to find them before the bad guys do. This top 10 will likely evolve rapidly until smart contract development reaches a state of steadiness and maturity.</p>
	</div>
</article>
		
	</div>
</div>


	<!-- /container -->
	</div>

	<!--Footer-->
	<footer class="page-footer font-small indigo pt-0" style="background-color:#4054b2;color:white">
	    <div class="container">
	        <div class="row">
	            <div class="col-md-12 py-5">
	                <div class="mb-5 flex-center" style="display:flex;align-items:center;justify-content:space-around;">
<!--
	                    <a>
	                        <i class="fab fa-ethereum fa-2x"></i>
	                    </a>
	                    <a>
	                        <i class="fab fa-ethereum fa-2x"></i>
	                    </a>-->
	                    <a>
	                        <i class="fab fa-ethereum fa-2x"></i>
	                    </a>

	                </div>
	            </div>
	        </div>
	    </div>

	    <div class="py-3 text-center" style="background-color:#33438e;">
	        <a href="https://www.nccgroup.trust" target="_blank">NCC Group</a> | <a href="https://cryptoservices.github.io/" target="_blank">Cryptography Services</a>
	    </div>

	</footer>
	<!--/Footer-->
	
	<!-- bootstrap.js -->
	<script src="https://code.jquery.com/jquery-3.2.1.slim.min.js" integrity="sha384-KJ3o2DKtIkvYIK3UENzmM7KCkRr/rE9/Qpg6aAZGJwFDMVNA/GpGFF93hXpG5KkN" crossorigin="anonymous"></script>
	<script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.12.9/umd/popper.min.js" integrity="sha384-ApNbgh9B+Y1QKtv3Rn7W3mgPxhU9K/ScQsAP7hUibX39j7fakFPskvXusvfa0b4Q" crossorigin="anonymous"></script>
	<script src="https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0/js/bootstrap.min.js" integrity="sha384-JZR6Spejh4U02d8jOt6vLEHfe/JQGiRRSQQxSfFWpi1MquVdAyjUar5+76PVCmYl" crossorigin="anonymous"></script>
	<!-- fontawesome.js -->
	<script defer src="https://use.fontawesome.com/releases/v5.0.8/js/all.js"></script>
	<!-- highlight.js -->
	<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
	<!-- script -->
	<script>
		// hljs.highlighting
		hljs.initHighlightingOnLoad();
	</script>
</body>
</html>
